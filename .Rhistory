result <- foreach(i = 1:3) %dopar% {
random_function(i)
}
# Stop the cluster
stopCluster(cl)
print(result)
library(doParallel)
random_function <- function(i) {
set.seed(123 + i)
runif(1)
}
num_cores <- detectCores()
cl <- makeCluster(num_cores)
registerDoParallel(cl)
result <- foreach(i = 1:3, .combine = c) %dopar% {
random_function(i)
}
stopCluster(cl)
print(result)
library(doParallel)
# Define a computationally expensive function
expensive_function <- function(i) {
set.seed(123 + i)  # Fix seed for reproducibility
sum(runif(10^6))   # Sum of 1 million random numbers
}
# -----------------------
# 1. Run Without Parallelization
# -----------------------
start_time_seq <- Sys.time()
result_seq <- sapply(1:10, expensive_function)
end_time_seq <- Sys.time()
time_seq <- end_time_seq - start_time_seq
print(paste("Sequential Execution Time:", time_seq))
# -----------------------
# 2. Run With Parallelization
# -----------------------
num_cores <- detectCores() - 1  # Use all but one core
cl <- makeCluster(num_cores)
registerDoParallel(cl)
start_time_par <- Sys.time()
result_par <- foreach(i = 1:10, .combine = c, .packages = "base") %dopar% {
expensive_function(i)
}
end_time_par <- Sys.time()
stopCluster(cl)
time_par <- end_time_par - start_time_par
print(paste("Parallel Execution Time:", time_par))
library(doParallel)
expensive_function <- function(i) {
set.seed(123 + i)  # Fix seed
sum(runif(10^6))
}
# -----------------------
# 1. Run Without Parallelization
# -----------------------
start_time_seq <- Sys.time()
result_seq <- sapply(1:10, expensive_function)
end_time_seq <- Sys.time()
time_seq <- end_time_seq - start_time_seq
print(paste("Sequential Execution Time:", time_seq))
# -----------------------
# 2. Run With Parallelization
# -----------------------
num_cores <- detectCores()
cl <- makeCluster(num_cores)
registerDoParallel(cl)
start_time_par <- Sys.time()
result_par <- foreach(i = 1:10, .combine = c, .packages = "base") %dopar% {
expensive_function(i)
}
end_time_par <- Sys.time()
stopCluster(cl)
time_par <- end_time_par - start_time_par
print(paste("Parallel Execution Time:", time_par))
library(rTensor)
library(doParallel)
library(foreach)
# Define CP decomposition function with a fixed seed
cp_decomp <- function() {
set.seed(123)  # Fix seed for reproducibility
tensor_data <- array(runif(4 * 5 * 6), dim = c(4, 5, 6))  # Create a tensor
tensor <- as.tensor(tensor_data)
cp(tensor, num_components = 3)  # Perform CP decomposition
}
# ----------------------
# 1. Sequential Execution
# ----------------------
start_time_seq <- Sys.time()
result_seq <- cp_decomp()  # Run sequentially
end_time_seq <- Sys.time()
time_seq <- end_time_seq - start_time_seq
print(paste("Sequential Execution Time:", time_seq))
# ----------------------
# 2. Parallel Execution
# ----------------------
num_cores <- detectCores() - 1  # Use all but one core
cl <- makeCluster(num_cores)
registerDoParallel(cl)
start_time_par <- Sys.time()
# Perform CP decomposition in parallel
result_par <- foreach(i = 1:10, .packages = "rTensor") %dopar% {
cp_decomp()
}
end_time_par <- Sys.time()
stopCluster(cl)
time_par <- end_time_par - start_time_par
print(paste("Parallel Execution Time:", time_par))
# ----------------------
# 3. Verify Results are Identical
# ----------------------
identical_result <- identical(result_seq, result_par[[1]])  # Compare first parallel result with sequential
print(paste("Are results identical?", identical_result))
# Define CP decomposition function with a fixed seed
# Define CP decomposition function with a fixed seed
cp_decomp <- function(i) {
set.seed(123 + i)  # Fix seed per iteration
tensor_data <- array(runif(4 * 5 * 6), dim = c(4, 5, 6))  # Create a tensor
tensor <- as.tensor(tensor_data)
cp(tensor, num_components = 3)  # Perform CP decomposition
}
# Number of times to run CP decomposition
num_runs <- 10
# ----------------------
# 1. Sequential Execution (Fair Comparison)
# ----------------------
start_time_seq <- Sys.time()
result_seq <- lapply(1:num_runs, cp_decomp)  # Run the same number of times as parallel
end_time_seq <- Sys.time()
time_seq <- end_time_seq - start_time_seq
print(paste("Sequential Execution Time:", time_seq))
# ----------------------
# 2. Parallel Execution
# ----------------------
num_cores <- detectCores() - 1  # Use all but one core
cl <- makeCluster(num_cores)
registerDoParallel(cl)
start_time_par <- Sys.time()
# Perform CP decomposition in parallel
result_par <- foreach(i = 1:num_runs, .packages = "rTensor") %dopar% {
cp_decomp(i)
}
end_time_par <- Sys.time()
stopCluster(cl)
time_par <- end_time_par - start_time_par
print(paste("Parallel Execution Time:", time_par))
# ----------------------
# 3. Verify Results are Identical
# ----------------------
identical_results <- all(mapply(identical, result_seq, result_par))  # Compare all results
print(paste("identical", identical_results))
update
setwd("C:/Users/yh95l/Desktop/CMTE")
setwd("C:/Users/yh95l/Desktop/CMTE")
file.remove(list.files("Data_1.1_1.2", full.names = TRUE))
file.remove(list.files("results_1.1_1.2", full.names = TRUE))
file.remove(list.files("Data_1.1_1.2", full.names = TRUE))
source("./parameters_1.1_1.2.R")
source("./DataGen_1.1_1.2.R")
library(foreach)
library(doParallel)
library("TRES")
source("./Evaluation.R")
source("./alg_CMTE/cmte_exp_1.1_1.2.R")
source("./alg_CMTE/cmte_exp_1.1_1.2.R")
library(MASS)
library(rTensor)
set.seed(123)
DGen_B <- function(r_vec, p) {
m <- length(r_vec)
Theta <- array(runif(p), dim = c(rep(1, m), p))
Theta <- as.tensor(Theta)
beta_list <- lapply(r_vec, function(r) {
beta <- runif(r, -1, 1)
qr.Q(qr(matrix(beta, ncol = 1)))
})
I_p <- diag(p)
B <- Theta
for (i in seq_len(m)) {
B <- ttl(B, list(beta_list[[i]]), ms = i)
}
B <- ttl(B, list(I_p), ms = m + 1)
return(list(Theta = Theta,B = B, beta_list = beta_list))
}
DGen_X <- function(n, p) {
p <- prod(p)
X <- matrix(rnorm(n * p), nrow = n)
X_tensor <- array(t(X), dim = c(p, n))
return(as.tensor(X_tensor))
}
DGen_Omega0 <- function(r) {
Or <- qr.Q(qr(matrix(rnorm((r - 1)^2), nrow = r - 1)))
diag_vals <- exp(seq(2, -2, length.out = r - 1))
Or %*% diag(diag_vals) %*% t(Or)
}
DGen_Sigma <- function(beta_list, Omega_c) {
m <- length(beta_list)
Sigma_list <- vector("list", m)
for (i in seq_len(m)) {
beta <- beta_list[[i]]
r <- nrow(beta)
d <- ncol(beta)
d0 <- r - d
Q_full <- qr.Q(qr(cbind(beta, matrix(runif(r * d0), nrow = r))))
beta0 <- Q_full[, (d + 1):r, drop = FALSE]
Or <- qr.Q(qr(matrix(rnorm(d0 * d0), nrow = d0)))
diag_vals <- exp(seq(2, -2, length.out = d0))
Omega0 <- Or %*% diag(diag_vals) %*% t(Or)
Sigma_list[[i]] <- beta %*% Omega_c %*% t(beta) + beta0 %*% Omega0 %*% t(beta0)
}
Reduce(kronecker, rev(Sigma_list))
}
DGen_E <- function(n, L) {
Z <- matrix(rnorm(n * ncol(L)), nrow = n)
Z %*% t(L)
}
DGen_Y <- function(B, X, eps, L, function_num) {
m <- length(dim(B)) - 1
r_vec <- dim(B)[1:m]
n <- dim(X@data)[2]
X_mat <- t(X@data)
X_tilde <- switch(
as.character(function_num),
"1" = X_mat,
"2" = exp(2 * abs(X_mat)),
"3" = sin(X_mat),
stop("Invalid function_num")
)
Bmat <- t(k_unfold(B, m = m + 1)@data)
E <- DGen_E(n, L)
Y_vec <- X_tilde %*% t(Bmat) + eps * E
array(t(Y_vec), dim = c(r_vec, n))
}
rp_grid <- unique(param_grid[c("r_index", "p")])
for (i in 1:nrow(param_grid)) {
r_vec   <- r_vec_list[[param_grid$r_index[i]]]
p       <- param_grid$p[i]
eps     <- param_grid$eps[i]
n       <- param_grid$n[i]
Omega_c <- param_grid$Omega_c[i]
f_num   <- param_grid$f_num[i]
r_str   <- paste(r_vec, collapse = "x")
dir_name <- sprintf("Data_1.1_1.2/SimData_n%d_p%d_r%s_eps%.2f_fn%d_rep%d",
n, p, r_str, eps, f_num, n_rep)
dir.create(dir_name, recursive = TRUE, showWarnings = FALSE)
message(sprintf("=== Start: n = %d, p = %d, r = %s, eps = %.2f, f_num = %d ===",
n, p, r_str, eps, f_num))
t_start <- Sys.time()
B_list <- DGen_B(r_vec, p)
B      <- B_list$B
beta_list <- B_list$beta_list
Sigma <- DGen_Sigma(beta_list, exp(Omega_c))
L <- chol(Sigma)
for (rep in 1:n_rep) {
rep_start <- Sys.time()
X <- DGen_X(n, p)
Y <- DGen_Y(B, X, eps, L, function_num = f_num)
file_name <- sprintf("%s/SimData_n%d_p%d_r%s_eps%.2f_fn%d_rep%d.RData",
dir_name, n, p, r_str, eps, f_num, rep)
save(Y, X, B_list, file = file_name)
if (rep %% ceiling(n_rep / 5) == 0 || rep == 1 || rep == n_rep) {
cur_time <- Sys.time()
elapsed <- difftime(cur_time, t_start, units = "secs")
message(sprintf("[Progress] rep %d / %d | Time = %s | Elapsed = %.1f sec | Params: n = %d, p = %d, r = %s, eps = %.2f, f_num = %d",
rep, n_rep, format(cur_time, "%H:%M:%S"), as.numeric(elapsed),
n, p, r_str, eps, f_num))
}
}
t_end <- Sys.time()
message(sprintf("=== Completed: n = %d, p = %d, r = %s, eps = %.2f, f_num = %d | Total Time: %.2f sec ===\n",
n, p, r_str, eps, f_num, as.numeric(difftime(t_end, t_start, units = "secs"))))
}
source("./alg_CMTE/cmte_exp_1.1_1.2.R")
source("./alg_CMTE/cmte_exp_1.1_1.2.R", echo = TRUE, print.eval = TRUE)
source("./parameters_1.1_1.2.R")
source("./alg_CMTE/cmte.R")
source("./Evaluation.R")
library(foreach)
library(doParallel)
library("TRES")
n_cores <- parallel::detectCores() - 1
cl <- makeCluster(n_cores)
registerDoParallel(cl)
set.seed(123)
results_log <- foreach(i = 1:nrow(param_grid), .packages = c("rTensor", "MASS", "TRES"), .combine = rbind) %dopar% {
tryCatch({
r_vec <- r_vec_list[[param_grid$r_index[i]]]
p     <- param_grid$p[i]
eps   <- param_grid$eps[i]
n     <- param_grid$n[i]
Omega <- param_grid$Omega[i]
f_num <- param_grid$f_num[i]
r_str <- paste(r_vec, collapse = "x")
cmte_1d_acc_list   <- numeric(n_rep)
cmte_ecd_acc_list  <- numeric(n_rep)
cmte_1d_time_list  <- numeric(n_rep)
cmte_ecd_time_list <- numeric(n_rep)
for (rep in 1:n_rep) {
input_file <- sprintf("Data_1.1_1.2/SimData_n%d_p%d_r%s_eps%.2f_fn%d_rep%d/SimData_n%d_p%d_r%s_eps%.2f_fn%d_rep%d.RData",
n, p, r_str, eps, f_num, n_rep,
n, p, r_str, eps, f_num, rep)
if (!file.exists(input_file)) {
message(sprintf("Missing file: %s", input_file))
next
}
load(input_file)  # loads Y, X, B_list
beta_list <- B_list$beta_list
M_list <- TMDDM(X@data, Y)
t1 <- system.time({
cmte_1d_est <- CMTE(X@data, Y, M_list, eps = 1e-6, method = "1D")
})["elapsed"]
cmte_1d_acc_list[rep] <- beta_acc(cmte_1d_est, beta_list)
cmte_1d_time_list[rep] <- t1
t2 <- system.time({
cmte_ecd_est <- CMTE(X@data, Y, M_list, eps = 1e-6, method = "ECD")
})["elapsed"]
cmte_ecd_acc_list[rep] <- beta_acc(cmte_ecd_est, beta_list)
cmte_ecd_time_list[rep] <- t2
# Print progress every 20%
if (rep %% ceiling(n_rep / 5) == 0 || rep == 1 || rep == n_rep) {
message(sprintf("[Progress] rep %d / %d | Params: n = %d, p = %d, r = %s, eps = %.2f, f_num = %d",
rep, n_rep, n, p, r_str, eps, f_num))
}
}
# Save result
output_file <- sprintf("results_1.1_1.2/coef_est_cmte_n%d_p%d_r%s_eps%.2f_fn%d_rep%d.RData",
n, p, r_str, eps, f_num, n_rep)
save(
cmte_1d_acc_list,
cmte_ecd_acc_list,
cmte_1d_time_list,
cmte_ecd_time_list,
file = output_file
)
# Return log message
data.frame(
n        = rep(n, n_rep),
f_num    = rep(f_num, n_rep),
r        = rep(r_str, n_rep),
rep      = seq_len(n_rep),
CMTE_1D  = cmte_1d_acc_list,
CMTE_1D_time = cmte_1d_time_list,
CMTE_ECD = cmte_ecd_acc_list,
CMTE_ECD_time = cmte_ecd_time_list
)
}, error = function(e) {
data.frame(n = n, f_num = f_num, r = r_str, rep = NA,
CMTE_1D = NA, CMTE_1D_time = NA,
CMTE_ECD = NA, CMTE_ECD_time = NA,
message = paste("ERROR:", e$message))
})
}
try(stopCluster(cl), silent = TRUE)  # stop old cluster if it exists
closeAllConnections()                # force-close socket and file connections
gc()                                 # trigger garbage collection
source("./parameters_1.1_1.2.R")
source("./alg_CMTE/cmte.R")
source("./Evaluation.R")
library(foreach)
library(doParallel)
library("TRES")
n_cores <- parallel::detectCores() - 1
cl <- makeCluster(n_cores)
registerDoParallel(cl)
set.seed(123)
results_log <- foreach(i = 1:nrow(param_grid), .packages = c("rTensor", "MASS", "TRES"), .combine = rbind) %dopar% {
tryCatch({
r_vec <- r_vec_list[[param_grid$r_index[i]]]
p     <- param_grid$p[i]
eps   <- param_grid$eps[i]
n     <- param_grid$n[i]
Omega <- param_grid$Omega[i]
f_num <- param_grid$f_num[i]
r_str <- paste(r_vec, collapse = "x")
cmte_1d_acc_list   <- numeric(n_rep)
cmte_ecd_acc_list  <- numeric(n_rep)
cmte_1d_time_list  <- numeric(n_rep)
cmte_ecd_time_list <- numeric(n_rep)
for (rep in 1:n_rep) {
input_file <- sprintf("Data_1.1_1.2/SimData_n%d_p%d_r%s_eps%.2f_fn%d_rep%d/SimData_n%d_p%d_r%s_eps%.2f_fn%d_rep%d.RData",
n, p, r_str, eps, f_num, n_rep,
n, p, r_str, eps, f_num, rep)
if (!file.exists(input_file)) {
message(sprintf("Missing file: %s", input_file))
next
}
load(input_file)  # loads Y, X, B_list
beta_list <- B_list$beta_list
M_list <- TMDDM(X@data, Y)
t1 <- system.time({
cmte_1d_est <- CMTE(X@data, Y, M_list, eps = 1e-6, method = "1D")
})["elapsed"]
cmte_1d_acc_list[rep] <- beta_acc(cmte_1d_est, beta_list)
cmte_1d_time_list[rep] <- t1
t2 <- system.time({
cmte_ecd_est <- CMTE(X@data, Y, M_list, eps = 1e-6, method = "ECD")
})["elapsed"]
cmte_ecd_acc_list[rep] <- beta_acc(cmte_ecd_est, beta_list)
cmte_ecd_time_list[rep] <- t2
# Print progress every 20%
if (rep %% ceiling(n_rep / 5) == 0 || rep == 1 || rep == n_rep) {
message(sprintf("[Progress] rep %d / %d | Params: n = %d, p = %d, r = %s, eps = %.2f, f_num = %d",
rep, n_rep, n, p, r_str, eps, f_num))
}
}
# Save result
output_file <- sprintf("results_1.1_1.2/coef_est_cmte_n%d_p%d_r%s_eps%.2f_fn%d_rep%d.RData",
n, p, r_str, eps, f_num, n_rep)
save(
cmte_1d_acc_list,
cmte_ecd_acc_list,
cmte_1d_time_list,
cmte_ecd_time_list,
file = output_file
)
# Return log message
data.frame(
n        = rep(n, n_rep),
f_num    = rep(f_num, n_rep),
r        = rep(r_str, n_rep),
rep      = seq_len(n_rep),
CMTE_1D  = cmte_1d_acc_list,
CMTE_1D_time = cmte_1d_time_list,
CMTE_ECD = cmte_ecd_acc_list,
CMTE_ECD_time = cmte_ecd_time_list
)
}, error = function(e) {
data.frame(n = n, f_num = f_num, r = r_str, rep = NA,
CMTE_1D = NA, CMTE_1D_time = NA,
CMTE_ECD = NA, CMTE_ECD_time = NA,
message = paste("ERROR:", e$message))
})
}
parallel::detectCores()
cl
source("./parameters_1.1_1.2.R")
source("./alg_CMTE/cmte.R")
source("./Evaluation.R")
library(foreach)
library(doParallel)
library("TRES")
n_cores <- max(1,parallel::detectCores() - 2)
cl <- makeCluster(n_cores)
registerDoParallel(cl)
set.seed(123)
results_log <- foreach(i = 1:nrow(param_grid), .packages = c("rTensor", "MASS", "TRES"), .combine = rbind) %dopar% {
tryCatch({
r_vec <- r_vec_list[[param_grid$r_index[i]]]
p     <- param_grid$p[i]
eps   <- param_grid$eps[i]
n     <- param_grid$n[i]
Omega <- param_grid$Omega[i]
f_num <- param_grid$f_num[i]
r_str <- paste(r_vec, collapse = "x")
cmte_1d_acc_list   <- numeric(n_rep)
cmte_ecd_acc_list  <- numeric(n_rep)
cmte_1d_time_list  <- numeric(n_rep)
cmte_ecd_time_list <- numeric(n_rep)
for (rep in 1:n_rep) {
input_file <- sprintf("Data_1.1_1.2/SimData_n%d_p%d_r%s_eps%.2f_fn%d_rep%d/SimData_n%d_p%d_r%s_eps%.2f_fn%d_rep%d.RData",
n, p, r_str, eps, f_num, n_rep,
n, p, r_str, eps, f_num, rep)
if (!file.exists(input_file)) {
message(sprintf("Missing file: %s", input_file))
next
}
load(input_file)  # loads Y, X, B_list
beta_list <- B_list$beta_list
M_list <- TMDDM(X@data, Y)
t1 <- system.time({
cmte_1d_est <- CMTE(X@data, Y, M_list, eps = 1e-6, method = "1D")
})["elapsed"]
cmte_1d_acc_list[rep] <- beta_acc(cmte_1d_est, beta_list)
cmte_1d_time_list[rep] <- t1
t2 <- system.time({
cmte_ecd_est <- CMTE(X@data, Y, M_list, eps = 1e-6, method = "ECD")
})["elapsed"]
cmte_ecd_acc_list[rep] <- beta_acc(cmte_ecd_est, beta_list)
cmte_ecd_time_list[rep] <- t2
# Print progress every 20%
if (rep %% ceiling(n_rep / 5) == 0 || rep == 1 || rep == n_rep) {
message(sprintf("[Progress] rep %d / %d | Params: n = %d, p = %d, r = %s, eps = %.2f, f_num = %d",
rep, n_rep, n, p, r_str, eps, f_num))
}
}
# Save result
output_file <- sprintf("results_1.1_1.2/coef_est_cmte_n%d_p%d_r%s_eps%.2f_fn%d_rep%d.RData",
n, p, r_str, eps, f_num, n_rep)
save(
cmte_1d_acc_list,
cmte_ecd_acc_list,
cmte_1d_time_list,
cmte_ecd_time_list,
file = output_file
)
# Return log message
data.frame(
n        = rep(n, n_rep),
f_num    = rep(f_num, n_rep),
r        = rep(r_str, n_rep),
rep      = seq_len(n_rep),
CMTE_1D  = cmte_1d_acc_list,
CMTE_1D_time = cmte_1d_time_list,
CMTE_ECD = cmte_ecd_acc_list,
CMTE_ECD_time = cmte_ecd_time_list
)
}, error = function(e) {
data.frame(n = n, f_num = f_num, r = r_str, rep = NA,
CMTE_1D = NA, CMTE_1D_time = NA,
CMTE_ECD = NA, CMTE_ECD_time = NA,
message = paste("ERROR:", e$message))
})
}
