detectCores() - 1
library(doParallel)
# Function that generates a random number (with fixed seed)
random_function <- function(i) {
set.seed(123 + i)  # Unique seed per iteration
runif(1)  # Generate a random number
}
# Detect available cores
num_cores <- detectCores()
# Create a cluster and register it
cl <- makeCluster(num_cores)
registerDoParallel(cl)
# Run parallel computation with a fixed seed per iteration
result <- foreach(i = 1:10, .combine = c, .packages = "base") %dopar% {
random_function(i)
}
# Stop the cluster
stopCluster(cl)
print(result)
library(doParallel)
# Function that generates a random number (with fixed seed)
random_function <- function(i) {
set.seed(123 + i)  # Unique seed per iteration
runif(1)  # Generate a random number
}
# Detect available cores
num_cores <- detectCores()
# Create a cluster and register it
cl <- makeCluster(num_cores)
registerDoParallel(cl)
# Run parallel computation with a fixed seed per iteration
result <- foreach(i = 1:10, .combine = c, .packages = "base") %dopar% {
random_function(i)
}
# Stop the cluster
stopCluster(cl)
print(result)
library(doParallel)
# Function that generates a random number (with fixed seed)
random_function <- function(i) {
set.seed(123 + i)  # Unique seed per iteration
runif(1)  # Generate a random number
}
# Detect available cores
num_cores <- detectCores()
# Create a cluster and register it
cl <- makeCluster(num_cores)
registerDoParallel(cl)
# Run parallel computation with a fixed seed per iteration
result <- foreach(i = 1:3, .combine = c) %dopar% {
random_function(i)
}
# Stop the cluster
stopCluster(cl)
print(result)
library(doParallel)
random_function <- function(i) {
set.seed(123 + i)
runif(1)
}
num_cores <- detectCores()
cl <- makeCluster(num_cores)
registerDoParallel(cl)
# Run parallel computation with a fixed seed per iteration
result <- foreach(i = 1:3) %dopar% {
random_function(i)
}
# Stop the cluster
stopCluster(cl)
print(result)
library(doParallel)
random_function <- function(i) {
set.seed(123 + i)
runif(1)
}
num_cores <- detectCores()
cl <- makeCluster(num_cores)
registerDoParallel(cl)
# Run parallel computation with a fixed seed per iteration
result <- foreach(i = 1:3) %dopar% {
random_function(i)
}
# Stop the cluster
stopCluster(cl)
print(result)
library(doParallel)
random_function <- function(i) {
set.seed(123 + i)
runif(1)
}
num_cores <- detectCores()
cl <- makeCluster(num_cores)
registerDoParallel(cl)
result <- foreach(i = 1:3, .combine = c) %dopar% {
random_function(i)
}
stopCluster(cl)
print(result)
library(doParallel)
# Define a computationally expensive function
expensive_function <- function(i) {
set.seed(123 + i)  # Fix seed for reproducibility
sum(runif(10^6))   # Sum of 1 million random numbers
}
# -----------------------
# 1. Run Without Parallelization
# -----------------------
start_time_seq <- Sys.time()
result_seq <- sapply(1:10, expensive_function)
end_time_seq <- Sys.time()
time_seq <- end_time_seq - start_time_seq
print(paste("Sequential Execution Time:", time_seq))
# -----------------------
# 2. Run With Parallelization
# -----------------------
num_cores <- detectCores() - 1  # Use all but one core
cl <- makeCluster(num_cores)
registerDoParallel(cl)
start_time_par <- Sys.time()
result_par <- foreach(i = 1:10, .combine = c, .packages = "base") %dopar% {
expensive_function(i)
}
end_time_par <- Sys.time()
stopCluster(cl)
time_par <- end_time_par - start_time_par
print(paste("Parallel Execution Time:", time_par))
library(doParallel)
expensive_function <- function(i) {
set.seed(123 + i)  # Fix seed
sum(runif(10^6))
}
# -----------------------
# 1. Run Without Parallelization
# -----------------------
start_time_seq <- Sys.time()
result_seq <- sapply(1:10, expensive_function)
end_time_seq <- Sys.time()
time_seq <- end_time_seq - start_time_seq
print(paste("Sequential Execution Time:", time_seq))
# -----------------------
# 2. Run With Parallelization
# -----------------------
num_cores <- detectCores()
cl <- makeCluster(num_cores)
registerDoParallel(cl)
start_time_par <- Sys.time()
result_par <- foreach(i = 1:10, .combine = c, .packages = "base") %dopar% {
expensive_function(i)
}
end_time_par <- Sys.time()
stopCluster(cl)
time_par <- end_time_par - start_time_par
print(paste("Parallel Execution Time:", time_par))
library(rTensor)
library(doParallel)
library(foreach)
# Define CP decomposition function with a fixed seed
cp_decomp <- function() {
set.seed(123)  # Fix seed for reproducibility
tensor_data <- array(runif(4 * 5 * 6), dim = c(4, 5, 6))  # Create a tensor
tensor <- as.tensor(tensor_data)
cp(tensor, num_components = 3)  # Perform CP decomposition
}
# ----------------------
# 1. Sequential Execution
# ----------------------
start_time_seq <- Sys.time()
result_seq <- cp_decomp()  # Run sequentially
end_time_seq <- Sys.time()
time_seq <- end_time_seq - start_time_seq
print(paste("Sequential Execution Time:", time_seq))
# ----------------------
# 2. Parallel Execution
# ----------------------
num_cores <- detectCores() - 1  # Use all but one core
cl <- makeCluster(num_cores)
registerDoParallel(cl)
start_time_par <- Sys.time()
# Perform CP decomposition in parallel
result_par <- foreach(i = 1:10, .packages = "rTensor") %dopar% {
cp_decomp()
}
end_time_par <- Sys.time()
stopCluster(cl)
time_par <- end_time_par - start_time_par
print(paste("Parallel Execution Time:", time_par))
# ----------------------
# 3. Verify Results are Identical
# ----------------------
identical_result <- identical(result_seq, result_par[[1]])  # Compare first parallel result with sequential
print(paste("Are results identical?", identical_result))
# Define CP decomposition function with a fixed seed
# Define CP decomposition function with a fixed seed
cp_decomp <- function(i) {
set.seed(123 + i)  # Fix seed per iteration
tensor_data <- array(runif(4 * 5 * 6), dim = c(4, 5, 6))  # Create a tensor
tensor <- as.tensor(tensor_data)
cp(tensor, num_components = 3)  # Perform CP decomposition
}
# Number of times to run CP decomposition
num_runs <- 10
# ----------------------
# 1. Sequential Execution (Fair Comparison)
# ----------------------
start_time_seq <- Sys.time()
result_seq <- lapply(1:num_runs, cp_decomp)  # Run the same number of times as parallel
end_time_seq <- Sys.time()
time_seq <- end_time_seq - start_time_seq
print(paste("Sequential Execution Time:", time_seq))
# ----------------------
# 2. Parallel Execution
# ----------------------
num_cores <- detectCores() - 1  # Use all but one core
cl <- makeCluster(num_cores)
registerDoParallel(cl)
start_time_par <- Sys.time()
# Perform CP decomposition in parallel
result_par <- foreach(i = 1:num_runs, .packages = "rTensor") %dopar% {
cp_decomp(i)
}
end_time_par <- Sys.time()
stopCluster(cl)
time_par <- end_time_par - start_time_par
print(paste("Parallel Execution Time:", time_par))
# ----------------------
# 3. Verify Results are Identical
# ----------------------
identical_results <- all(mapply(identical, result_seq, result_par))  # Compare all results
print(paste("identical", identical_results))
update
setwd("C:/Users/yh95l/Desktop/CMTE")
source("./parameters.R")
source("./DataGen.R")
source("./cmte.R")
source("./Evaluation.R")
library(foreach)
library(doParallel)
library("TRES")
n_cores <- parallel::detectCores() - 1
cl <- makeCluster(n_cores)
registerDoParallel(cl)
set.seed(123)
results_log <- foreach(i = 1:nrow(param_grid), .packages = c("rTensor", "MASS"), .combine = rbind) %dopar% {
r_vec <- c(param_grid$r1[i], param_grid$r2[i])
p     <- param_grid$p[i]
eps   <- param_grid$eps[i]
n     <- param_grid$n[i]
Omega <- param_grid$Omega[i]
f_num <- param_grid$f_num[i]
r_str <- paste(r_vec, collapse = "x")
input_file <- sprintf("data/SimData_n%d_p%d_r%s_eps%.2f_fn%d_rep%d.RData",
n, p, r_str, eps, f_num, n_rep)
if (!file.exists(input_file)) {
return(data.frame(n = n, f_num = f_num, message = "File missing"))
}
load(input_file)
cmte_acc_list <- numeric(n_rep)
trr_acc_list  <- numeric(n_rep)
tmddm_acc_list <- numeric(n_rep)
for (rep in 1:n_rep) {
Y <- Y_list[[rep]]
X <- X_list[[rep]]
beta_list <- B_list_all[[rep]]$beta_list
M_xy <- TMDDM(X@data, Y)
cmte_est <- CMTE(X@data, Y, M_xy)
cmte_acc_list[rep] <- beta_acc(cmte_est, beta_list)
TReg <- TRR.fit(X@data, Y, u = c(1, 1), method = "1D")
trr_est <- TReg$Gamma
trr_acc_list[rep] <- beta_acc(trr_est, beta_list)
M_xy <- TMDDM(X@data, Y)
tmddm_est <- lapply(M_xy, function(Mk) eigen(Mk)$vectors[, 1])
tmddm_acc_list[rep] <- beta_acc(tmddm_est, beta_list)
}
# Save result
output_file <- sprintf("results/coef_est_n%d_p%d_r%s_eps%.2f_fn%d_rep%d.RData",
n, p, r_str, eps, f_num, n_rep)
save(cmte_acc_list, trr_acc_list, tmddm_acc_list, file = output_file)
# Return message line
msg <- sprintf("n=%d, fn=%d | CMTE=%.4f, TRR=%.4f, TMDDM=%.4f",
n, f_num, mean(cmte_acc_list), mean(trr_acc_list), mean(tmddm_acc_list))
data.frame(n = n, f_num = f_num, message = msg)
}
results_log <- foreach(i = 1:nrow(param_grid), .packages = c("rTensor", "MASS","TRES"), .combine = rbind) %dopar% {
r_vec <- c(param_grid$r1[i], param_grid$r2[i])
p     <- param_grid$p[i]
eps   <- param_grid$eps[i]
n     <- param_grid$n[i]
Omega <- param_grid$Omega[i]
f_num <- param_grid$f_num[i]
r_str <- paste(r_vec, collapse = "x")
input_file <- sprintf("data/SimData_n%d_p%d_r%s_eps%.2f_fn%d_rep%d.RData",
n, p, r_str, eps, f_num, n_rep)
if (!file.exists(input_file)) {
return(data.frame(n = n, f_num = f_num, message = "File missing"))
}
load(input_file)
cmte_acc_list <- numeric(n_rep)
trr_acc_list  <- numeric(n_rep)
tmddm_acc_list <- numeric(n_rep)
for (rep in 1:n_rep) {
Y <- Y_list[[rep]]
X <- X_list[[rep]]
beta_list <- B_list_all[[rep]]$beta_list
M_xy <- TMDDM(X@data, Y)
cmte_est <- CMTE(X@data, Y, M_xy)
cmte_acc_list[rep] <- beta_acc(cmte_est, beta_list)
TReg <- TRR.fit(X@data, Y, u = c(1, 1), method = "1D")
trr_est <- TReg$Gamma
trr_acc_list[rep] <- beta_acc(trr_est, beta_list)
M_xy <- TMDDM(X@data, Y)
tmddm_est <- lapply(M_xy, function(Mk) eigen(Mk)$vectors[, 1])
tmddm_acc_list[rep] <- beta_acc(tmddm_est, beta_list)
}
# Save result
output_file <- sprintf("results/coef_est_n%d_p%d_r%s_eps%.2f_fn%d_rep%d.RData",
n, p, r_str, eps, f_num, n_rep)
save(cmte_acc_list, trr_acc_list, tmddm_acc_list, file = output_file)
# Return message line
msg <- sprintf("n=%d, fn=%d | CMTE=%.4f, TRR=%.4f, TMDDM=%.4f",
n, f_num, mean(cmte_acc_list), mean(trr_acc_list), mean(tmddm_acc_list))
data.frame(n = n, f_num = f_num, message = msg)
}
print(results_log$message)
#generate table
source("./table_output.R")
source("./parameters.R")
source("./DataGen.R")
for (i in 1:nrow(param_grid)) {
r_vec <- r_vec_list[[param_grid$r_index[i]]]
p     <- param_grid$p[i]
eps   <- param_grid$eps[i]
n     <- param_grid$n[i]
Omega <- param_grid$Omega[i]
f_num <- param_grid$f_num[i]
# Lists to collect replications
Y_list <- vector("list", n_rep)
X_list <- vector("list", n_rep)
B_list_all <- vector("list", n_rep)
for (rep in 1:n_rep) {
B_list    <- DGen_B(r_vec, p)
B         <- B_list$B
beta_list <- B_list$beta_list
X         <- DGen_X(n, p)
Sigma     <- DGen_Sigma(beta_list, exp(Omega))
Y         <- DGen_Y(B, X, eps, Sigma, function_num = f_num)
# Store results
Y_list[[rep]]     <- Y
X_list[[rep]]     <- X
B_list_all[[rep]] <- B_list
}
# Save everything in one file
r_str <- paste(r_vec, collapse = "x")
filename <- sprintf("data/SimData_n%d_p%d_r%s_eps%.2f_fn%d_rep%d.RData", n, p, r_str, eps, f_num, n_rep)
save(Y_list, X_list, B_list_all, file = filename)
message("Saved to: ", filename)
}
n_cores <- parallel::detectCores() - 1
cl <- makeCluster(n_cores)
registerDoParallel(cl)
set.seed(123)
results_log <- foreach(i = 1:nrow(param_grid), .packages = c("rTensor", "MASS","TRES"), .combine = rbind) %dopar% {
r_vec <- c(param_grid$r1[i], param_grid$r2[i])
p     <- param_grid$p[i]
eps   <- param_grid$eps[i]
n     <- param_grid$n[i]
Omega <- param_grid$Omega[i]
f_num <- param_grid$f_num[i]
r_str <- paste(r_vec, collapse = "x")
input_file <- sprintf("data/SimData_n%d_p%d_r%s_eps%.2f_fn%d_rep%d.RData",
n, p, r_str, eps, f_num, n_rep)
if (!file.exists(input_file)) {
return(data.frame(n = n, f_num = f_num, message = "File missing"))
}
load(input_file)
cmte_acc_list <- numeric(n_rep)
trr_acc_list  <- numeric(n_rep)
tmddm_acc_list <- numeric(n_rep)
for (rep in 1:n_rep) {
Y <- Y_list[[rep]]
X <- X_list[[rep]]
beta_list <- B_list_all[[rep]]$beta_list
M_xy <- TMDDM(X@data, Y)
cmte_est <- CMTE(X@data, Y, M_xy)
cmte_acc_list[rep] <- beta_acc(cmte_est, beta_list)
TReg <- TRR.fit(X@data, Y, u = c(1, 1), method = "1D")
trr_est <- TReg$Gamma
trr_acc_list[rep] <- beta_acc(trr_est, beta_list)
M_xy <- TMDDM(X@data, Y)
tmddm_est <- lapply(M_xy, function(Mk) eigen(Mk)$vectors[, 1])
tmddm_acc_list[rep] <- beta_acc(tmddm_est, beta_list)
}
# Save result
output_file <- sprintf("results/coef_est_n%d_p%d_r%s_eps%.2f_fn%d_rep%d.RData",
n, p, r_str, eps, f_num, n_rep)
save(cmte_acc_list, trr_acc_list, tmddm_acc_list, file = output_file)
# Return message line
msg <- sprintf("n=%d, fn=%d | CMTE=%.4f, TRR=%.4f, TMDDM=%.4f",
n, f_num, mean(cmte_acc_list), mean(trr_acc_list), mean(tmddm_acc_list))
data.frame(n = n, f_num = f_num, message = msg)
}
print(results_log$message)
#generate table
source("./table_output.R")
results_log <- foreach(i = 1:nrow(param_grid), .packages = c("rTensor", "MASS", "TRES"), .combine = rbind) %dopar% {
r_vec <- r_vec_list[[param_grid$r_index[i]]]
p     <- param_grid$p[i]
eps   <- param_grid$eps[i]
n     <- param_grid$n[i]
Omega <- param_grid$Omega[i]
f_num <- param_grid$f_num[i]
r_str <- paste(r_vec, collapse = "x")
input_file <- sprintf("data/SimData_n%d_p%d_r%s_eps%.2f_fn%d_rep%d.RData",
n, p, r_str, eps, f_num, n_rep)
if (!file.exists(input_file)) {
return(data.frame(n = n, f_num = f_num, message = "File missing"))
}
load(input_file)  # loads Y_list, X_list, B_list_all
cmte_acc_list   <- numeric(n_rep)
trr_acc_list    <- numeric(n_rep)
tmddm_acc_list  <- numeric(n_rep)
for (rep in 1:n_rep) {
Y <- Y_list[[rep]]
X <- X_list[[rep]]
beta_list <- B_list_all[[rep]]$beta_list
# CMTE
M_xy <- TMDDM(X@data, Y)
cmte_est <- CMTE(X@data, Y, M_xy)
cmte_acc_list[rep] <- beta_acc(cmte_est, beta_list)
# TRR
TReg <- TRR.fit(X@data, Y, u = rep(1, length(r_vec)), method = "1D")
trr_est <- TReg$Gamma
trr_acc_list[rep] <- beta_acc(trr_est, beta_list)
# TMDDM
M_xy <- TMDDM(X@data, Y)
tmddm_est <- lapply(M_xy, function(Mk) eigen(Mk)$vectors[, 1])
tmddm_acc_list[rep] <- beta_acc(tmddm_est, beta_list)
}
# Save result
output_file <- sprintf("results/coef_est_n%d_p%d_r%s_eps%.2f_fn%d_rep%d.RData",
n, p, r_str, eps, f_num, n_rep)
save(cmte_acc_list, trr_acc_list, tmddm_acc_list, file = output_file)
# Return log message
msg <- sprintf("n=%d, f_num=%d, r=%s | CMTE=%.4f, TRR=%.4f, TMDDM=%.4f",
n, f_num, r_str,
mean(cmte_acc_list, na.rm = TRUE),
mean(trr_acc_list, na.rm = TRUE),
mean(tmddm_acc_list, na.rm = TRUE))
data.frame(n = n, f_num = f_num, r = r_str, message = msg)
}
print(results_log$message)
#generate table
source("./table_output.R")
setwd("C:/Users/yh95l/Desktop/CMTE")
source("./parameters.R")
source("./DataGen.R")
source("./cmte.R")
source("./Evaluation.R")
library(foreach)
library(doParallel)
n_cores <- parallel::detectCores() - 1
cl <- makeCluster(n_cores)
registerDoParallel(cl)
set.seed(123)
results_log <- foreach(i = 1:nrow(param_grid), .packages = c("rTensor", "MASS", "TRES"), .combine = rbind) %dopar% {
r_vec <- r_vec_list[[param_grid$r_index[i]]]
p     <- param_grid$p[i]
eps   <- param_grid$eps[i]
n     <- param_grid$n[i]
Omega <- param_grid$Omega[i]
f_num <- param_grid$f_num[i]
r_str <- paste(r_vec, collapse = "x")
input_file <- sprintf("data/SimData_n%d_p%d_r%s_eps%.2f_fn%d_rep%d.RData",
n, p, r_str, eps, f_num, n_rep)
if (!file.exists(input_file)) {
return(data.frame(n = n, f_num = f_num, message = "File missing"))
}
load(input_file)  # loads Y_list, X_list, B_list_all
cmte_acc_list   <- numeric(n_rep)
trr_acc_list    <- numeric(n_rep)
tmddm_acc_list  <- numeric(n_rep)
for (rep in 1:n_rep) {
Y <- Y_list[[rep]]
X <- X_list[[rep]]
beta_list <- B_list_all[[rep]]$beta_list
# CMTE
M_xy <- TMDDM(X@data, Y)
cmte_est <- CMTE(X@data, Y, M_xy)
cmte_acc_list[rep] <- beta_acc(cmte_est, beta_list)
# TRR
TReg <- TRR.fit(X@data, Y, u = rep(1, length(r_vec)), method = "1D")
trr_est <- TReg$Gamma
trr_acc_list[rep] <- beta_acc(trr_est, beta_list)
# TMDDM
M_xy <- TMDDM(X@data, Y)
tmddm_est <- lapply(M_xy, function(Mk) eigen(Mk)$vectors[, 1])
tmddm_acc_list[rep] <- beta_acc(tmddm_est, beta_list)
}
# Save result
output_file <- sprintf("results/coef_est_n%d_p%d_r%s_eps%.2f_fn%d_rep%d.RData",
n, p, r_str, eps, f_num, n_rep)
save(cmte_acc_list, trr_acc_list, tmddm_acc_list, file = output_file)
# Return log message
msg <- sprintf("n=%d, f_num=%d, r=%s | CMTE=%.4f, TRR=%.4f, TMDDM=%.4f",
n, f_num, r_str,
mean(cmte_acc_list, na.rm = TRUE),
mean(trr_acc_list, na.rm = TRUE),
mean(tmddm_acc_list, na.rm = TRUE))
data.frame(n = n, f_num = f_num, r = r_str, message = msg)
}
print(results_log$message)
#generate table
source("./table_output.R")
